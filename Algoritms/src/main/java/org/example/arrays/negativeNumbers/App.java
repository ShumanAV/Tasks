package org.example.arrays.negativeNumbers;

/*
Задача:
 есть двумерный массив целых чисел, с числами можно проводить следующие манипуляции: по горизонтали или по вертикали
 сразу два числа можно умножать на -1, делать это можно не ограниченное количество раз, цель: вернуть максимально
 возможную сумму элементов всей матрицы. Если количество отрицательных чисел четное число, значит можно все
 отрицательные числа  превратить в положительные, если нечетное число, значит в итоге останется одно число отрицательное,
  и нужно найти минимальное из всей матрицы число, которое можно сделать или оставить отрицательным
 */

public class App {
    public static void main(String[] args) {
        int[][] arr = {{2  , 3  , 5  , 7  , -9},
                       {4  , 11 , -8 , -10, 12},
                       {-17, 3  , -24, -2 , -5},
                       {7  , -10, -12, 8  , 16},
                       {-14, 3  , -2 , 1  , 9 }};
        System.out.println("Максимальная сумма: " + maxMatrixSum(arr));
    }

    // Сложность O(n2)
    // Решение, находим максимально возможную сумму всей матрицы, минимальное значение по модулю и число отрицательных
    // чисел. Далее возвращаем результат как максимальная сумма минус два минимума умноженные на остаток от деления на
    // два количества отрицательных чисел, если их четное число, значит умножаем на 0 и макс сумма не изменится, если
    // нечетное число, то в остатке будет 1, умножаем минимум на 1 два раза, т.к. мин число с минусом, и оно было
    // включено с макс сумму
    private static int maxMatrixSum(int[][] arr) {
        int sum = 0, negativeCount = 0, min = 1000_000_000;
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                int num = arr[i][j];
                sum += Math.abs(num);
                min = Math.min(min, Math.abs(num));
                if (num < 0) {
                    negativeCount++;
                }
            }
        }
        return sum - 2 *(negativeCount % 2 * min);
    }
}
